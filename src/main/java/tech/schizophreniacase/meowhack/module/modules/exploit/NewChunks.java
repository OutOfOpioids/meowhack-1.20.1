/*
 * This file is part of the BleachHack distribution (https://github.com/BleachDev/BleachHack/).
 * Copyright (c) 2021 Bleach and contributors.
 *
 * This source code is subject to the terms of the GNU General Public
 * License, version 3. If a copy of the GPL was not distributed with this
 * file, You can obtain one at: https://www.gnu.org/licenses/gpl-3.0.txt
*/
package tech.schizophreniacase.meowhack.module.modules.exploit;

import net.minecraft.fluid.FluidState;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Direction;
import tech.schizophreniacase.meowhack.module.Category;
import tech.schizophreniacase.meowhack.module.Module;
import tech.schizophreniacase.meowhack.util.world.ChunkProcessor;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import static tech.schizophreniacase.meowhack.util.Wrapper.mc;

public class NewChunks extends Module {
    public static NewChunks INSTANCE;

    public NewChunks() {
        super("NewChunks", Category.EXPLOIT);
        INSTANCE = this;
        this.enabled = true;
    }

    private static final Direction[] SKIP_DIRS = new Direction[] { Direction.UP, Direction.EAST, Direction.NORTH, Direction.WEST, Direction.SOUTH };
    private static final Direction[] SEARCH_DIRS = new Direction[] { Direction.EAST, Direction.NORTH, Direction.WEST, Direction.SOUTH, Direction.UP};

    private final Set<ChunkPos> newChunks = Collections.synchronizedSet(new HashSet<>());
    private final Set<ChunkPos> oldChunks = Collections.synchronizedSet(new HashSet<>());

    private ChunkProcessor processor = new ChunkProcessor(1, (chunkPos, worldChunk) -> {
        if(!newChunks.contains(chunkPos) && mc.world.getChunkManager().getChunk(chunkPos.x, chunkPos.z) == null) {
            for(int x = 0; x < 16; x++) {
                for(int y = mc.world.getBottomY(); y < mc.world.getTopY(); y++) {
                    for(int z = 0; z < 16; z++) {
                        FluidState fluidState = worldChunk.getFluidState(x, y, z);
                        if(!fluidState.isEmpty() && !fluidState.isStill()) {
                            oldChunks.add(chunkPos);
                            return;
                        }
                    }
                }
            }
        }

    }, null,
    (blockPos, blockState) -> {
        if(!blockState.getFluidState().isEmpty() && !blockState.getFluidState().isStill()) {
            ChunkPos chunkPos = new ChunkPos(blockPos);
            for(Direction dir : SEARCH_DIRS) {
                if(mc.world.getBlockState(blockPos.offset(dir)).getFluidState().isStill() && !oldChunks.contains(chunkPos)) {
                    newChunks.add(chunkPos);
                    return;
                }
            }
        }
    });
}
